---
title: 数组
tags: 
  - 算法
date: 2022-03-23
prev: false
next: ./02.md
sidebarDepth: 5
---

[[toc]]

## 数组里面有 10 万个数据，取第一个元素和第 10 万个 元素的时间相差多少？

:::details 查看答案
数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)  
得出结论：消耗时间几乎一致，差异可以忽略不计
:::

## 旋转数组

:::tip
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 

示例 1：  
输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3  
输出: [5, 6, 7, 1, 2, 3, 4]  
解释:  
向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]  
向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]  
向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]

示例 2：  
输入: [-1, -100, 3, 99] 和 k = 2  
输出: [3, 99, -1, -100]  
解释:  
向右旋转 1 步: [99, -1, -100, 3]  
向右旋转 2 步: [3, 99, -1, -100]
:::

:::details 查看答案

```js
function rotate(arr, k) {
    const len = arr.length
    // 超出数组长度取模
    const step = k % len
    return arr.slice(-step).concat(arr.slice(0, len - step))
}
// rotate([1, 2, 3, 4, 5, 6], 7) => [6, 1, 2, 3, 4, 5]
```
:::

## 找出 1 - 10000 之间的所有对称数

:::details 查看答案
```js
// [...Array(10000).keys()] 也可以
[...new Array(10000).keys()].filter((x) => {
    return x.toString().length > 1 && x === Number(x.toString().split('').reverse().join(''))
})
```
:::

## 移动零

:::tip
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。  
示例:  
输入: [0,1,0,3,12]  
输出: [1,3,12,0,0]  
复制代码说明: 必须在原数组上操作，不能拷贝额外的数组，尽量减少操作次数。
:::

:::details 查看答案

```js
function zeroMove(array) {
    let len = array.length;
    let j = 0;
    for (let i = 0; i < len - j; i++) {
        if (array[i] === 0) {
            array.push(0);
            array.splice(i, 1);
            i--;
            j++;
        }
    }
    return array;
}
```
:::


## 数组中找出重复元素
:::tip
var arr = ["a", "c", "a", {"a": 2}, 112, {"a": 2}, 112, 234, {"b": 1}]
// [ 'a', { a: 2 }, 112 ]
:::

:::details map+计数器
时间复杂度O(n ^ 2)
```js
function findRepeat(arr) {
	let map = new Map()
	let result = []
	arr.forEach((val) => {
		const str = (typeof val === 'object' && val !== null) ? JSON.stringify(val) : val
		map.set(str, map.get(str) ? map.get(str) + 1 : 1)
	})
	map.forEach((val, key) => {
		if (val > 1) {
			try {
				result.push(JSON.parse(key))
			} catch (error) {
				result.push(key)
			}
		}
	})
	return result
}

// [ 'a', { a: 2 }, 112 ]
```
map的遍历还可以
```js
for(let [k, v] of map.entries()) {
    if(v > 1) {
        try {
            result.push(JSON.parse(k))
        } catch (error) {
            result.push(k)
        }
    }
}
```
:::

:::details 辅助数组
时间复杂度O(n ^ 2)
```js
function findRepeat(arr) {
	let result = []
	let arr1 = []
	arr.forEach((val) => {
		let str = (typeof val === 'object' && val !== null) ? JSON.stringify(val) : val
		if (arr1.includes(str)) {
			result.push(val)
		} else {
			arr1.push(str)
		}
	})
	return result
}

// [ 'a', { a: 2 }, 112 ]
```
:::

:::details 排序+双指针
时间复杂度O(n)
```js
function findRepeat(arr) {
	const result = []
	let i = 0
	arr.sort()
	while(i < arr.length) {
		let str1 = (typeof arr[i] === 'object' && arr[i] !== null) ? JSON.stringify(arr[i]) : arr[i]
		let str2 = (typeof arr[i+1] === 'object' && arr[i+1] !== null) ? JSON.stringify(arr[i+1]) : arr[i+1]
		if(str1 === str2) {
			result.push(arr[i])
			i = i+2
		} else {
			i++
		}
	}
	return result
}

// [ 112, { a: 2 }, 'a' ]
```
:::

## 接雨水问题

:::tip
LeetCode上面有这道题，题号42  
给定n个非负整数表示每个宽度为1的柱子的高度图，计算彼此排列的柱子，下雨之后能接多少雨水。  
示例1：  
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]  
输出：6  

实例2：  
输入：height = [4,2,0,3,2,5]  
输出：9
:::right
[接雨水问题详细解释](https://juejin.cn/post/6953558954416799781)
:::

:::details 两个辅助数组
时间复杂度O(n)，空间复杂度O(n)
```js
function trap(height) {
    if(!height.length) return 0;
    let left = []
    let right = []
    let lmax = rmax = 0
    let len = height.length
    let result = 0
    // 把左右最大出水量求出来
    for(let i = 0; i < len; i++) {
        lmax = Math.max(height[i], lmax)
        rmax = Math.max(height[len-i-1], rmax)
        left[i] = lmax
        right[len- i - 1] = rmax
    }
    // 算出最小的然后累加
    for(let i = 0; i < len; i++) {
        result += Math.min(left[i],right[i]) - height[i]
    }
    return result
};

```
- 最后的累加可以使用reduce
```js
return height.reduce((prev, item, index) => {
    return prev + Math.min(left[index],right[index]) - item
}, 0)
```
:::

:::details 一个辅助数组
时间复杂度O(n)，空间复杂度O(n)
```js
function trap(height) {
    if(!height.length) return 0;
    let left = []
    let lmax = rmax = 0
    let len = height.length
    let result = 0
    // 从前往后遍历
    for(let i = 0; i < len; i++) {
        lmax = Math.max(height[i], lmax)
        left[i] = lmax
    }
    // 从后往前遍历
    for(let i = len - 1; i >= 0; i--) {
        rmax = Math.max(height[i], rmax)
        result += Math.min(left[i],rmax) - height[i]
    }
    return result
};
```
:::