---
title: Vue2原理
tags: 
  - vue
date: 2022-03-16
prev: false
next: ./02.md
sidebarDepth: 5
---

[[toc]]

## 1. 请简述 Vue 响应式原理

:::details 查看简单答案
1. 数据初始化的时候数据data创建响应式对象，遍历所有的属性用Object.defineProperty方法将其转换成setter和getter。
2. 在get方法中获取值并且去收集依赖，如果有子对象就给子对象收集依赖。
3. 在set方法中，判断如果设置的新值与旧值不相等，将新值赋值给旧值，然后调用dep.notify方法派发通知。
:::

:::details 查看详细答案
Vue响应式指的是Vue数据响应式，Vue数据响应式指的是数据驱动视图，在数据发生变化的时候自动更新视图，不需要手动操作DOM。

源码中在数据初始化的时候initData中，是通过observe函数给数据data创建响应式对象的，这个函数的功能是通过创建一个Observer构造函数，将数据data的所有属性转化成getter和setter。

具体的做法：

1. 在Observer构造函数里面，添加了dep属性，还遍历所有的属性用defineReactive方法将其转换成setter和getter
2. 在defineReactive内部，调用了Object.defineProperty，在get方法中获取值并且去收集依赖，如果有子对象就给子对象收集依赖。在set方法中，判断如果设置的新值与旧值不相等，将新值赋值给旧值，然后更新视图。
:::

## 2. 具体如何收集依赖?

:::details 查看答案
- 初始化的时候在$mount方法中调用了mountComponent方法
- mountComponent方法内部创建了Watcher对象
- 在Watcher对象中首先将自己存储到了Dep对象的target属性中，然后调用了updateComponent方法
- updateComponent这个方法将render函数渲染到页面上
- 渲染过程中在访问每个属性的时候，就会进入属性的get方法
- 在get方法中进行依赖收集，将Watcher对象添加到Dep的subs数组中，并且将dep对象添加到Watcher对象的newDeps数组中。
:::

## 3. 具体如何发布通知?

:::details 查看答案
- 当值进行修改的时候，会触发属性的set方法，这个时候会调用dep.notify()方法。
- Dep对象会遍历其subs数组，每个元素都是一个Watcher对象，并调用其update方法。
- 然后其会调用updateComponent方法更新视图。
:::

## 4. 观察者模式和订阅发布模式的区别

- 观察者模式中主体和观察者是互相感知的。
- 发布订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知。
## 4. Vue中key的作用 <Badge text="TODO" type="error"/>

:::details 查看答案
key 是给每一个 vnode 的唯一id，可以依靠 key 更准确、更快的拿到 oldVnode 中对应的 vnode 节点。
:::

## 6. Virtual DOM 真的比操作原生 DOM 快吗?

:::details 查看答案
不一定。这是一个性能 vs. 可维护性的取舍。  
框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。  
针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。
:::

## 在 Vue 中，子组件为何不可以修改父组件传递的 Prop？
:::details 查看答案
如果修改了，Vue 是如何监控到属性的修改并给出警告的。

1、子组件为何不可以修改父组件传递的 Prop 单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。 
2、如果修改了，Vue 是如何监控到属性的修改并给出警告的。

在 initProps 的时候，在 defineReactive 时通过判断是否在开发环境，如果是开发环境，会在触发 set 的时候判断是否此 key 是否处于 updatingChildren 中被修改，如果不是，说明此修改来自子组件，触发 warning 提示。

需要特别注意的是，当你从子组件修改的 prop 属于基础类型时会触发提示。这种情况下，你是无法修改父组件的数据源的， 因为基础类型赋值时是值拷贝。  
你直接将另一个非基础类型（Object, array）赋值到此 key 时也会触发提示(但实际上不会影响父组件的数据源)， 当你修改 object 的属性时不会触发提示，并且会修改父组件数据源的数据。
:::

## Vue 的父组件和子组件生命周期钩子执行顺序是什么

:::details 查看答案
### 创建
父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

### 更新
父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated

### 销毁
父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed

:::

## vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？

:::details 查看答案

vue中并没有给元素添加事件代理。

事件代理主要有什么作用是？
- 事件代理能够避免我们逐个的去给元素新增和删除事件。
- 事件代理比每一个元素都绑定一个事件性能要更好。

从vue的角度上来看：
1. 在v-for中，我们直接用一个for循环就能在模板中将每个元素都绑定上事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器都移除掉。所以事件代理能做到的第一点vue已经给我们做到了
2. 在v-for中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件代理的性能差别不大，所以也没必要用事件代理。

如果我们自己在非 vue 中需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。
:::

## React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化 到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？ 

:::details 查看答案
三种优化来降低复杂度：
1. 如果父节点不同，放弃对子节点的比较，直接删除旧节点然后添加新的 节点重新渲染。
2. 如果子节点有变化，Virtual DOM 不会计算变化的是什么，而是重新渲染。
3. 通过唯一的 key 策略。
:::