---
title: 架构
tags: 
  - server
date: 2022-03-23
prev: false
next: false
author: 黄鸭
sidebarDepth: 5
---

## 1.项目中熔断和限流怎么做的？

:::details 查看答案
- 熔断：在发生故障的时候,熔断保证错误减少
- 降级：为了保证核心功能,降低或关闭部分功能保证核心功能
- 限流：控制单位时间内的请求数量
:::

## 2.一致性哈希和普通哈希区别？

:::details 查看答案
当hash命中的机器宕机时,一致性hash能引导数据到下一个可用的机器上执行
:::

## 2.非对称加密慢怎么解决？

:::details 查看答案
使用非对称加密传输秘钥,实施对称加密
:::

## 2.有100G的文本文件，我要解析出这些文本中包含的URL并统计出来，取出其中的Top10，要求用并发编程加速。

:::details 查看答案
hash分文件,每个文件聚合,大根堆筛选前10个
海量数据问题套路
- 1.hash映射,hash统计,堆/快速/归并排序
- 2.多层划分
- 3.bloomfilter/bitmap
- 4.trie树/数据库/倒排索引
- 5.外排序
- 6.mapreduce
:::

## 网页爬虫原理

:::details 查看答案
bfs,布隆过滤器
:::

## 会RPC是吧？让你设计一个RPC框架，你主要会关注哪几个点，简单介绍下？

:::details 查看答案
- RPC是像使用本地函数一样使用远程接口
- 一个简单的rpc需要满足一下几点
- 1.功能,需要支持同步异步等调用过程
- 2.连接,选择http还是tcp/ip
- 3.协议,选择json xml来满足跨语言需求
- 4.调度,选择主节点满足注册,监控的功能
- 5.push和pull 短轮训,长轮训 慢消费,客户端是否繁忙,保证是否有序
:::

## RPC是基于TCP和UDP？数据传输过程中的简单流程又是怎样的？

:::details 查看答案
- 发送时先将数据序列化,然后封包发出
- 接收时先解包然后数据反序列化
:::

## 客户端请求一个不存在的端口，会发生什么？

:::details 查看答案
- udp: 如果目标端口未开放返回rst(端口未打开),如果开放则不会返回任何内容(没有内容)
- tcp:如果目标端口开放返回syn/ack(请求超时),如果未开放返回rst/ack(端口未打开)
:::

## 设计消息队列应该考虑些什么问题，消息持久化的文件存储格式应该怎么设计

:::details 查看答案
- 消息队列的功能:解耦,最终一致性,广播,错峰控流
- 消息队列本质是rpc+存储
- 除了rpc设计思路外还需要考虑存储持久化和非持久化
:::

## RPC和HTTP的区别

:::details 查看答案
- 他们都是应用协议
- RPC属于私有协议,可以自定义协议
- HTTP属于公有协议,主要服务于浏览器
:::

## TCP和UDP的区别，TCP保证可靠的机制

:::details 查看答案
- 三次握手四次挥手
- 检验和,判断是否错误
- 序列号,可靠,按序,去重,多次发送一次确认
- 确认应答,应答下一个标识
- 超时重传,无应答时重传
- 流量控制
- 拥塞控制
:::

## 讲一下流量控制的过程

:::details 查看答案
- a告诉b自己的缓存大小为rwnd,b向a传递的窗口就为rwnd
- 流量控制和拥塞控制取小值
:::

## redis和mysql数据一致性问题(缓存和持久化一致性问题怎么解决的)

:::details 查看答案
- 更新缓存,更新数据库
- 更新数据库,更新缓存
- 删除缓存,更新数据库
- 更新数据库,更新缓存
- 读数据库,写缓存
- 改变顺序会发生问题
- 所以采用延时双删策略
:::

## Protobuf和Json之间的区别

:::details 查看答案
- gRPC的沟通内容是protobuf,二进制
- protobuf跨语言,兼容好
- protobuf速度快,体积小
- json是文本类型的
- json可视化
- json js可以直接使用
:::





## TCP 的各种标志位

:::details 查看答案
- SYN是开启连接
- seq序号用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记
- ACK是指回复包，
- ack是只有ACK标志为1时，确认序号字段才有效，ack = seq + 1
- FIN是结束连接（单向断开，优雅断开），
- RST是重置连接（双向都直接不能处理了），
- PSH是数据推送，
:::

## FIN-WAIT-2是什么时候的？(四次挥手状态)

:::details 查看答案
- 客户端四次挥手的时候,
- 一开始客户端的状态是established,他给服务端发断开连接的时候客户端的状态变成FIN-WAIT-1
- 服务端起始状态是established,接收到消息后状态会变成CLOSE-WAIT
- 客户端收到服务端的第一个消息后变成FIN-WAIT-2
- 服务端要准备好所有东西发送第二个连接之后服务端状态变成LAST-ACK
- 客户端收到服务端的第二个消息后变成了TIME-WAIT(这种状态会持续2MSL)
- 客户端在2MSL之后会自动变为CLOSED,服务端在收到客户端给的反馈后变成CLOSED
:::

## 三次握手状态

:::details 查看答案
- 一开始客户端状态位CLOSED
- 服务端是CLOSED转LISTEN
- 客户端给服务端发消息时自己状态变成SYN-SEND
- 服务端收到消息并给客户端发消息之后状态变成SYN-REVD
- 客户端收到消息之后状态变成established并给服务端发消息
- 服务端收到消息后状态变为established
:::

## timewait，closewait状态

:::details 查看答案
- 服务端起始状态是established,接收到消息后状态会变成CLOSE-WAIT
- 客户端收到服务端的第二个消息后变成了TIME-WAIT(这种状态会持续2MSL)

## 四次挥手时不需要close wait，等待服务端要发送数据时，一次性把ack和fin发过去可以吗？

:::details 查看答案
- 服务器接收数据后会立即返回ack
- 等数据准备完成之后才会发送fin.
:::

## 四次挥手中，服务端请求断开连接的时候，客户端回复ACK确认后，就立即关闭连接，然后2MSL等待放在服务端为什么不可以？

:::details 查看答案
- 2MSL功能
- 客户端在等待服务器的再次确认,服务器没有必要等待
- 第一用于保证客户端发送的最后一个ACK报文可以到达服务器，如果这个ACK报文丢失，服务器会觉得客户端没有收到我发的请求断开报文，于是服务器就会重发一次，如果客户端在这个2MSL时间段内收到重传的报文，就会重新给出回应报文，还会重启2MSL计时器。
- 第二是在这个2WSL时间中，可以使本链接持续时间内产生的所有报文段从网络中消失，这样新的TCP三次握手的时候就不会出现旧链接中失效的请求报文。
:::

## tcpip三次握手建立过程标志位

:::details 查看答案
- 客户端->SYN=1 seq=x
- 服务端->SYN=1 ACK=1 ack=x+1 seq=y
- 客户端->ACK=1 ack=y+1 seq=x+1
:::

## tcpip四次挥手过程表示位

:::details 查看答案
- 客户端->FIN=1 seq=u
- 服务端->ACK=1 seq=v ack=u+1
- 服务端->ACK=1 FIN=1 seq=w ack=v+1
- 客户端->ACK=1 seq=u+1 ack=w+1
:::

## MSL是什么

:::details 查看答案
- tcp_fin_timeout默认值为60 msl值为30s
- 报文最大生存时间,tcp允许不同的实现可以设置不同的MSL值
:::

## 计算机网络应用层协议有哪些。

:::details 查看答案
http ftp dns websocket
:::